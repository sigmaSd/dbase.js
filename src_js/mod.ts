// mod_inline.ts is generated by a script
import { dbf_needs_memo, read_dbf_with_types } from "../lib/dbase_js.js";

export type Encoding = "utf8" | "cp850" | "cp1252" | "ascii";

/** A record from a dBase file - object with string keys and various value types */
export type DbfRecord = Record<string, string | number | boolean | Date | null>;

/**
 * Reads a dBase (.dbf) file from a path, automatically detecting and loading memo files.
 *
 * This is the only function you need - it handles everything automatically:
 * - Loads the DBF file
 * - Auto-detects if memo files (.fpt/.dbt) are needed
 * - Finds and loads the corresponding memo file
 * - Parses all field types correctly
 * - Returns clean JavaScript objects
 *
 * @param dbfPath Path to the .dbf file
 * @param encoding Text encoding to use. Defaults to "cp850" (DOS Latin-1)
 * @returns Array of record objects
 *
 * @example
 * ```typescript
 * // Simplest usage - works with any DBF file
 * const records = readDbf("/path/to/data.dbf");
 *
 * // With encoding for international text
 * const records = readDbf("/path/to/data.dbf", "cp1252");
 *
 * // Process the data
 * console.log(`Found ${records.length} records`);
 * records.forEach(record => {
 *   console.log(record.NAME, record.DATE);
 * });
 * ```
 */
export function readDbf(
  dbfPath: string,
  encoding: Encoding = "cp850",
): DbfRecord[] {
  // Load the DBF file
  const dbfData = Deno.readFileSync(dbfPath);

  // Check if this DBF file needs a memo file
  const needsMemo = dbf_needs_memo(dbfData);

  let memoData: Uint8Array | null = null;
  if (needsMemo) {
    // Try to find and load memo file automatically
    memoData = findMemoFile(dbfPath);
    if (!memoData) {
      const triedPaths = getMemoPathsToTry(dbfPath);
      throw new Error(
        `This DBF file contains memo fields but no memo file could be found.\n` +
          `Looked for: ${triedPaths.join(", ")}\n\n` +
          `Make sure the memo file (.fpt or .dbt) exists in the same directory as the DBF file.`,
      );
    }
  }

  // Read the DBF file (only once!) with field type metadata
  const jsonString = read_dbf_with_types(dbfData, memoData, encoding);
  const result = JSON.parse(jsonString);

  // Convert date fields to proper Date objects using field type metadata
  return result.records.map((record: DbfRecord) =>
    convertDatesWithTypes(record, result.field_types)
  );
}

/**
 * Try to find and load the memo file for a given DBF path
 */
function findMemoFile(dbfPath: string): Uint8Array | null {
  const memoPaths = getMemoPathsToTry(dbfPath);

  for (const memoPath of memoPaths) {
    try {
      return Deno.readFileSync(memoPath);
    } catch {
      // Continue trying other extensions
    }
  }

  return null;
}

/**
 * Get all possible memo file paths to try for a given DBF path
 */
function getMemoPathsToTry(dbfPath: string): string[] {
  const basePath = dbfPath.replace(/\.[^.]*$/, ""); // Remove extension
  return [
    basePath + ".fpt",
    basePath + ".FPT",
    basePath + ".dbt",
    basePath + ".DBT",
  ];
}

/**
 * Convert date fields to proper Date objects using field type metadata
 */
function convertDatesWithTypes(
  record: DbfRecord,
  fieldTypes: Record<string, string>,
): DbfRecord {
  const converted: DbfRecord = {};

  for (const [key, value] of Object.entries(record)) {
    const fieldType = fieldTypes[key];

    if (fieldType === "Date" && typeof value === "string" && value !== null) {
      // Parse ISO date strings like "2024-09-13"
      const dateMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (dateMatch) {
        const year = parseInt(dateMatch[1]);
        const month = parseInt(dateMatch[2]) - 1; // JavaScript months are 0-based
        const day = parseInt(dateMatch[3]);
        converted[key] = new Date(year, month, day);
      } else {
        converted[key] = value;
      }
    } else if (
      fieldType === "DateTime" && typeof value === "string" && value !== null
    ) {
      // Parse ISO datetime strings like "2024-09-13T14:30:00"
      const dateTimeMatch = value.match(
        /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})$/,
      );
      if (dateTimeMatch) {
        const year = parseInt(dateTimeMatch[1]);
        const month = parseInt(dateTimeMatch[2]) - 1; // JavaScript months are 0-based
        const day = parseInt(dateTimeMatch[3]);
        const hour = parseInt(dateTimeMatch[4]);
        const minute = parseInt(dateTimeMatch[5]);
        const second = parseInt(dateTimeMatch[6]);
        converted[key] = new Date(year, month, day, hour, minute, second);
      } else {
        converted[key] = value;
      }
    } else {
      converted[key] = value;
    }
  }

  return converted;
}

// Example usage and test when run as main module
if (import.meta.main) {
  const testPath = Deno.args[0];

  const startTime = performance.now();
  const records = readDbf(testPath);
  const endTime = performance.now();

  console.log(`   ‚úÖ Success! ${records.length} records`);
  console.log(`   ‚è±Ô∏è  Time: ${(endTime - startTime).toFixed(2)}ms`);
  console.log(
    `   üìä Rate: ${
      (records.length / (endTime - startTime) * 1000).toFixed(0)
    } records/sec`,
  );

  // Show sample data
  const sample = records[0];
  console.log(`   üìù Fields: ${Object.keys(sample).length}`);
  if (sample.EXAMENS && typeof sample.EXAMENS === "string") {
    console.log(`   üóíÔ∏è  Memo detected: ${sample.EXAMENS.length} chars`);
  }
  console.log(sample);
}
